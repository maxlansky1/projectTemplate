# {{diagram}} C4 Model

## Общее описание

C4 Model — это подход к визуализации архитектуры программного обеспечения, разработанный для упрощения и стандартизации способа описания и документирования архитектуры систем. Название "C4" происходит от четырёх уровней детализации, которые позволяют постепенно "углубляться" в архитектуру: **Контекст (Context)**, **Контейнеры (Containers)**, **Компоненты (Components)** и **Код (Code)**.

В отличие от традиционных подходов, таких как UML, C4 Model не перегружен сложной нотацией и символами, а, напротив, делает акцент на простоте и понятности. Он помогает разработчикам, архитекторам и заинтересованным лицам (stakeholders) легко воспринимать архитектурные решения, не погружаясь сразу в детали реализации. Это особенно важно в условиях, когда проекты становятся всё более сложными, а коммуникация между командами — критически важной.

C4 Model можно сравнить с картами: как на карте Google Maps можно приближать и отдалять масштаб, чтобы увидеть как общий обзор города, так и конкретный дом на улице, так и в архитектуре ПО можно переключаться между разными уровнями детализации, чтобы понять, как система вписывается в окружение, какие у неё компоненты и как они устроены внутри.

C4 Model был разработан **Саймоном Брауном (Simon Brown)**, консультантом по программной архитектуре, в 2006 году. Он столкнулся с проблемой, с которой сталкиваются многие архитекторы и разработчики: **отсутствием понятного, последовательного и структурированного способа описания архитектуры программного обеспечения**.

На тот момент, несмотря на наличие таких языков моделирования, как UML или ArchiMate, большинство команд всё равно использовали упрощённые диаграммы "из коробки" — с прямоугольниками, стрелками и надписями, часто несоблюдая никакой стандартизации. В результате диаграммы были непоследовательными, запутанными и плохо читаемыми. Это мешало эффективной коммуникации внутри команд и с внешними заинтересованными сторонами.

Саймон Браун предложил более простую и практичную альтернативу — C4 Model. Он не отвергал существующие языков моделирования, а, скорее, предлагал "лёгкий" способ описания архитектуры, который можно использовать как на этапе проектирования, так и для документирования уже существующих систем.

Модель получила широкое признание в сообществе разработчиков и архитекторов, особенно в Agile-среде, где важна скорость и ясность коммуникации. На сегодняшний день C4 Model стал стандартом де-факто для визуализации архитектуры в современных IT-компаниях.

### Основные принципы и цели

Принципы

- **Простота и ясность**: диаграммы должны быть понятны не только техническим специалистам, но и бизнес-пользователям.
- **Последовательность**: использование единообразных обозначений и подходов для всех уровней диаграмм.
- **Иерархичность**: каждый уровень диаграммы предоставляет определённый уровень детализации, что позволяет адаптировать представление под аудиторию.
- **Фокус на коммуникацию**: C4 Model создан не просто для документирования, а для эффективной передачи знаний о системе.

Цели

- **Повышение понятности архитектуры**: сделать архитектурные решения доступными для понимания всеми участниками проекта.
- **Упрощение документирования**: облегчить процесс создания и поддержки архитектурной документации.
- **Поддержка проектирования**: помочь командам обсуждать архитектурные решения на разных уровнях абстракции.
- **Улучшение коммуникации**: сократить разрыв между техническими и нетехническими заинтересованными сторонами.
- **Повышение зрелости архитектурных практик**: способствовать более системному подходу к визуализации архитектуры в команде и компании.

### Нотация

C4 Model **не зависит от нотации** и не предписывает использование какой-либо конкретной. Тем не менее, вы должны убедиться, что **нотация диаграмм понятна** и диаграммы **читаемы**. Хороший способ проверить это — задать себе вопрос: **можно ли понять диаграмму без дополнительного описания**? Вы можете использовать **чек-лист для проверки диаграмм архитектуры ПО**, чтобы помочь себе.

Ниже приведены **общие рекомендации**, связанные с нотацией.

#### Диаграммы

- Каждая диаграмма должна иметь **заголовок**, описывающий тип диаграммы и её область охвата (например, **"Диаграмма контекста для системы X"**).
- Каждая диаграмма должна иметь **ключ/легенду**, объясняющую используемую нотацию (например, формы, цвета, стили границ, типы линий, стрелки и т.д.).
- Аббревиатуры и сокращения (бизнес/доменные или технологические) должны быть понятны **всем аудиториям** или пояснены в **ключе/легенде диаграммы**.

#### Элементы

- Тип каждого элемента должен быть **указан явно** (например, **Человек**, **Программная система**, **Контейнер** или **Компонент**).
- У каждого элемента должно быть **короткое описание**, чтобы можно было **сразу понять ключевые обязанности**.
- У каждого контейнера и компонента должна быть **явно указана технология**.

#### Отношения

- Каждая линия должна представлять **одностороннее отношение**.
- Каждая линия должна быть **подписана**, при этом подпись должна соответствовать **направлению и цели отношения** (например, зависимости или потоку данных). Старайтесь быть **настолько конкретными, насколько возможно**, избегая одиночных слов, таких как "Uses".
- Отношения между контейнерами (обычно представляющие собой межпроцессное взаимодействие) должны **иметь явно указанную технологию/протокол**.

#### Цвета

Хотя во многих примерах диаграмм и инструментах используются **синие и серые прямоугольники**, это **не является требованием C4 Model**, и вы **свободны использовать любые цвета**, какие пожелаете! Главное, чтобы **цветовая кодировка была последовательной** (внутри и между диаграммами) и учитывались такие факторы, как **чёрно-белая печать, дальтонизм** и т.д.

#### Ключ/легенда диаграммы

Используемая нотация должна быть **максимально самодостаточной**, но **все диаграммы должны иметь ключ/легенду**, чтобы **явно указать нотацию**. Это относится и к диаграммам, созданным с использованием таких нотаций, как UML, ArchiMate и SysML, поскольку **не все могут знать используемую нотацию**.

## Абстракции

Для создания "карт вашего кода" нам нужно определиться с общим набором **абстракций**, с помощью которых можно описать статическую структуру программной системы. В C4 Model:

- **Программная система** состоит из одного или нескольких **контейнеров** (приложений и хранилищ данных), каждый из которых содержит один или несколько **компонентов**, которые, в свою очередь, реализованы с помощью одного или нескольких **элементов кода** (классов, интерфейсов, объектов, функций и т.д.).
- **Люди** (актёры, роли, персоны, конкретные лица и т.п.) используют создаваемые программные системы.

C4 Model — это подход, **ориентированный на абстракции**, основанный на концепциях, которые отражают то, как архитекторы и разработчики думают о программном обеспечении и создают его. Небольшой набор абстракций и типов диаграмм делает C4 Model лёгким в изучении и использовании.

### Программная система (Software System)

Программная система — это **наивысший уровень абстракции**, описывающий нечто, что приносит пользу своим пользователям, будь то люди или другие системы. Это включает как систему, которую вы моделируете, так и другие программные системы, от которых она зависит (или наоборот).

К сожалению, термин "программная система" — самый сложный для определения среди абстракций C4 Model, и это не помогает тому, что каждая организация использует свою терминологию для описания одного и того же, применяя термины вроде "приложение", "продукт", "сервис" и т.д.

Один из способов думать об этом — представить, что программная система — это нечто, что создаёт одна команда разработчиков, которой она принадлежит, за которую она отвечает и чьи внутренние детали реализации она видит. Возможно, код для этой системы находится в одном репозитории, и любой член команды может его изменить. В большинстве случаев граница программной системы соответствует границе команды. Также может быть так, что всё, что внутри границ программной системы, разворачивается одновременно.

**Обычно не являются программными системами** в C4 Model:

- Домены продукта
- Ограниченные контексты (bounded contexts)
- Бизнес-возможности
- Команды фичей
- Трибы, сквады и т.д.

### Контейнер (Container)

**Не Docker!** В C4 Model **контейнер** представляет собой **приложение или хранилище данных**. Контейнер — это то, что должно быть запущено, чтобы общая программная система работала. На практике контейнером может быть:

- **Серверное веб-приложение**: например, Java EE веб-приложение на Apache Tomcat, ASP.NET MVC приложение на Microsoft IIS, Ruby on Rails на WEBrick, Node.js приложение и т.д.
- **Клиентское веб-приложение**: JavaScript-приложение в браузере с Angular, Backbone.js, jQuery и т.д.
- **Клиентское десктопное приложение**: Windows-приложение на WPF, macOS-приложение на Objective-C, кроссплатформенное на JavaFX и т.д.
- **Мобильное приложение**: iOS-приложение, Android-приложение, Windows Phone и т.д.
- **Консольное серверное приложение**: автономное приложение, батч-процесс и т.д.
- **Серверная функция (serverless)**: например, Amazon Lambda, Azure Function и т.д.
- **База данных**: схема или база данных в СУБД, документное хранилище, графовая база данных и т.д. (MySQL, SQL Server, Oracle, MongoDB, Neo4j и т.д.)
- **Хранилище объектов или контента**: например, Amazon S3, Azure Blob Storage, CDN (Akamai, CloudFront и т.д.)
- **Файловая система**: локальная файловая система или часть сетевой (SAN, NAS и т.д.)
- **Скрипт оболочки**: Bash-скрипт и т.д.

Контейнер — это, по сути, **граница выполнения** вокруг какого-то кода или данных. Название "контейнер" было выбрано, чтобы не ассоциировать его с физической природой выполнения. Например, один сервер Java EE вроде Apache Tomcat может запускать несколько веб-приложений в одной JVM, но каждое из них изолировано. В процессе разработки вы можете запускать три веб-приложения на одном сервере Tomcat, но в проде каждое из них может быть развернуто на отдельном сервере. В этом случае каждое приложение — это "C4 контейнер", а развертывание — отдельная концепция.

#### Часто задаваемые вопросы

**Почему "контейнер"?**  
Термины вроде "процесс", "приложение", "сервер", "развёртываемая единица" и т.д. несут за собой определённые ассоциации, поэтому "контейнер" был выбран как общий способ описать нечто, внутри чего живут компоненты. С одной стороны, жаль, что контейнеризация стала популярной, потому что теперь разработчики ассоциируют "контейнер" с Docker. С другой — между C4-контейнером и инфраструктурным (Docker) контейнером может быть хорошая параллель.

**Веб-приложения: один контейнер или два?**  
Если вы создаёте серверное веб-приложение (Spring MVC, ASP.NET, Ruby on Rails и т.д.), которое в основном генерирует статический HTML, это один контейнер. Если же там много JavaScript (например, SPA на Angular), то это **два контейнера**.  
Хотя на этапе развертывания серверное веб-приложение включает и клиентский, и серверный код, разделение на два контейнера делает явным, что это разные пространства процессов, общающихся через межпроцессное взаимодействие (например, JSON по HTTPS). Это также позволяет отдельно "приближать" каждый контейнер, чтобы показать его компоненты.

**Является ли JAR, DLL, сборка C# контейнером?**  
Обычно — **нет**. Контейнер — это **время выполнения**, в то время как JAR, сборки, DLL — это способы организации кода **внутри приложений**.

**Следует ли показывать хранилища данных как программные системы или контейнеры?**  
Часто задаваемый вопрос: следует ли показывать такие сервисы, как Amazon S3, Amazon RDS, Azure SQL Database, CDN и т.д. как программные системы или контейнеры?  
Хотя вы и не управляете этими сервисами напрямую, у вас есть **владение и ответственность** за используемые бакеты, схемы баз данных и т.д. Поэтому их следует считать **контейнерами**, поскольку они являются важной частью архитектуры, даже если размещены в другом месте.

### Компонент (Component)

Слово "компонент" — чрезвычайно перегруженный термин в разработке ПО. В C4 Model **компонент** — это **группировка связанной функциональности**, инкапсулированной за хорошо определённым интерфейсом. Если вы используете язык вроде Java или C#, самый простой способ думать о компоненте — как о **наборе классов за интерфейсом**.

В C4 Model **компоненты не являются отдельно развертываемыми единицами**. Развертываемой единицей является **контейнер**. То есть все компоненты внутри контейнера выполняются в одном и том же процессном пространстве. То, как компоненты упакованы (один компонент в JAR или много компонентов в одном JAR), — отдельный вопрос.

#### Компоненты vs Код

Компонент — это **способ подняться на один уровень абстракции** от строительных блоков, доступных в используемом языке программирования. Например:

- **Объектно-ориентированные языки (Java, C#, C++ и т.д.)**: компонент состоит из классов и интерфейсов.
- **Процедурные языки (C)**: компонент может состоять из нескольких C-файлов в определённой директории.
- **JavaScript**: компонент может быть модулем, состоящим из объектов и функций.
- **Функциональные языки**: компонент может быть модулем (F#, Haskell и т.д.), логически сгруппированным набором функций, типов и т.д.

Если вы используете ООП-язык, ваш компонент будет реализован с помощью одного или нескольких классов. Рассмотрим пример.

#### Пример: Spring PetClinic

Spring PetClinic — это пример кодовой базы, иллюстрирующей создание веб-приложения на Java с использованием Spring MVC. Это программная система, предназначенная для воображаемой ветеринарной клиники, хранящей информацию о животных, их владельцах, посещениях и ветеринарах. Система предназначена только для сотрудников клиники.

Технически система состоит из веб-приложения и схемы реляционной базы данных.  
Версия веб-приложения, которую мы рассмотрим, имеет традиционную архитектуру слоёв: MVC-контроллеры, сервисы с "бизнес-логикой" и репозитории для доступа к данным. Также есть доменные и вспомогательные классы.

Если скачать репозиторий, открыть его в IDE и построить UML-диаграмму классов, вы получите диаграмму всех Java-классов и интерфейсов, плюс их связей. Свойства и методы скрыты, чтобы не перегружать картину.

Такая диаграмма показывает **слишком много деталей**. Чтобы упростить, можно скрыть те классы, которые не имеют значения для архитектурного обсуждения (например, модели/доменные классы, утилиты). После перегруппировки получается диаграмма, показывающая архитектурные слои (контроллеры, сервисы, репозитории), но всё ещё на уровне **кода**.

Чтобы подняться на уровень выше, нужно сгруппировать **кодовые элементы** в **компоненты**, представляющие связанную функциональность. В примере каждый веб-контроллер — отдельный компонент, а остальные интерфейсы и их реализации сгруппированы в компоненты.

После удаления шума на уровне кода получается диаграмма, показывающая **архитектурные компоненты**, а не классы.

#### Часто задаваемые вопросы

**Является ли JAR, сборка C#, DLL, модуль, пакет, пространство имён, папка компонентом?**  
Возможно, но **обычно — нет**. C4 Model — это о **времени выполнения** (контейнерах) и **разделении функциональности** (компонентах), а не об организационных единицах вроде JAR-файлов, сборок, пакетов, пространств имён или структуры папок.

Однако может быть **один к одному** маппинг между этими сущностями и компонентами (например, при использовании архитектуры шестигранника). С другой стороны, один компонент может быть реализован с помощью кода из нескольких JAR-файлов, особенно если используются сторонние библиотеки.

### Код (Code)

Наконец, **компоненты состоят из одного или нескольких элементов кода**, построенных из базовых строительных блоков используемого языка программирования — классов, интерфейсов, перечислений, функций, объектов и т.д.

### Микросервисы (Microservices)

В широком смысле, при использовании C4 Model для диаграммирования микросервисов есть два основных варианта, хотя всё зависит от того, что именно вы понимаете под "микросервисом".

#### Этап 1 — монолитная архитектура

Представим, что вы работаете в небольшом стартапе и строите программную систему "X", предлагающую клиентам возможности A, B и C.  
Диаграмма контекста может выглядеть так:

(Пример: система X, пользователи, другие системы)

Самый быстрый и дешёвый способ — использовать **монолитную архитектуру**, состоящую из одного веб-приложения и одной схемы базы данных.  
Диаграмма контейнеров:

(Пример: веб-приложение + база данных)

#### Этап 2 — архитектура микросервисов

Через пару лет трафик растёт, команда расширяется, и монолит начинает тормозить. Решено переходить к микросервисам.

Согласно определению Льюиса и Фаулера:

> Микросервисная архитектура — это подход к разработке **одного приложения** как набора небольших сервисов, каждый из которых запускается в собственном процессе и общается через лёгкие механизмы, часто через HTTP API. Эти сервисы построены вокруг бизнес-возможностей и могут быть независимо развернуты с помощью полностью автоматизированных механизмов.

Подставим "программная система" вместо "приложение":

> Микросервисная архитектура — это подход к разработке **одной программной системы** как набора небольших сервисов, каждый из которых запускается в собственном процессе и общается через лёгкие механизмы, часто через HTTP API. Эти сервисы построены вокруг бизнес-возможностей и могут быть независимо развернуты с помощью полностью автоматизированных механизмов.

Во втором этапе, несмотря на расширение команды, вы решили остаться **одной командой**, поэтому диаграмма контекста не меняется.  
Но диаграмма контейнеров изменяется: UI остаётся монолитным, а бизнес-логика и данные выносятся в отдельные микросервисы.  
Каждый микросервис — это **пара контейнеров**: API и база данных.  
На диаграмме это может быть показано с помощью цветового кодирования или обособленных блоков.

Если новая бизнес-функция реализуется через AWS Lambda, то она будет отдельным контейнером.

#### Этап 3 — Закон Конвея (Conway’s Law)

Когда компания растёт, вы решаете оптимизировать разработку, следуя **закону Конвея**. Вы разделяете команду на несколько:  
- Команда X: владеет UI для функций A, B, C, D  
- Команда A: владеет сервисом A  
- Команда B: владеет сервисом B  
- и т.д.

Теперь каждый сервис становится **отдельной программной системой**, и вы можете рисовать диаграммы контекста и контейнеров для каждой команды.

#### Итог

Подход к диаграммированию микросервисной архитектуры зависит от **владения** отдельными сервисами: являются ли они деталями реализации **внутри одной программной системы** или **отдельными программными системами**, принадлежащими разным командам.

### Очереди и топики (Queues and Topics)

Представим архитектуру, где сервисы A и B публикуют сообщения, а C и D — их потребляют.  
Часто диаграмма выглядит так:  
(Сервисы A, B → шина сообщений → сервисы C, D)

Хотя это может быть верной моделью, диаграмма "хаб и спица" скрывает **связность** между продюсерами и консьюмерами.

#### Точка-точка (Point-to-point)

Проблема в том, что **шаблон сообщений** представлен как C4-контейнер. Лучше думать о **каждой очереди или топике** как о **контейнере**.  
Ведь очередь — это **хранилище данных**, куда помещаются и извлекаются сообщения.  
Теперь диаграмма ясно показывает, что A связан с C через очередь X, B — с D через очередь Y.

#### Публикация/подписка (Pub/Sub)

Диаграмму можно изменить, чтобы показать роли паблишеров и сабскрайберов, изменив направление стрелок.

#### Итог

Существует несколько способов диаграммировать архитектуру на основе сообщений:

- **Неправильно**: показывать шину как C4-контейнер.
- **Правильно**: показывать очереди и топики как C4-контейнеры.
- **Правильно**: использовать нотацию "через" для обозначения сообщений.

### Часто задаваемые вопросы

#### Можно ли изменить терминологию?

Да, терминология (контекст, контейнеры, компоненты, код) подходит многим организациям, но если в вашей команде уже используется другая, или термины "компоненты", "классы" не подходят (например, в функциональных языках), вы можете изменить терминологию, **главное — чтобы все её понимали**.

#### Можно ли добавить больше уровней абстракции?

Иногда кажется, что четырёх уровней недостаточно. Но проблема часто в том, что мы используем **нечёткую терминологию**, и поэтому трудно отнести "базу данных" к контейнеру или компоненту.  
**Дебаты** о том, что есть что, заставляют **понимать**, что вы на самом деле имеете в виду, и **делать точные выборы**.

C4 Model силён в **малом наборе фиксированных иерархических абстракций**, помогающих командам **точно рассуждать** о своих системах.

Если вы действительно чувствуете, что нужно больше уровней, **делайте это с осторожностью**, и **чётко определите** каждый новый уровень, иначе вы снова окажетесь в ситуации с нечёткими диаграммами.

## Диаграммы

C4 Model получил своё название от основного набора **статических структурных диаграмм**: диаграмма контекста, диаграмма контейнеров, диаграмма компонентов и диаграмма кода. Эти диаграммы позволяют по-разному "приближать" архитектуру программной системы, чтобы рассказывать разные истории разным аудиториям. При этом вам необязательно использовать все 4 уровня диаграмм — достаточно тех, которые действительно приносят пользу. Для большинства команд разработки ПО достаточно диаграммы контекста и диаграммы контейнеров.

Кроме основных структурных диаграмм, существуют также **вспомогательные диаграммы**, которые могут быть полезны в определённых ситуациях.

```{csv-table}
:header: "Тип диаграммы", "Описание"
"Контекст (Context)", "Показывает, как программная система вписывается в окружение: кто её использует и с какими другими системами она взаимодействует."
"Контейнеры (Containers)", "Показывает основные компоненты системы: приложения, базы данных, внешние сервисы и т.д."
"Компоненты (Components)", "Детализирует внутренности отдельных контейнеров: какие компоненты находятся внутри и как они связаны."
"Код (Code)", "Отображает реализацию компонентов на уровне исходного кода: классы, интерфейсы, функции и т.д."
"Динамические диаграммы", "Показывают, как компоненты взаимодействуют во времени: потоки данных, вызовы API и т.д."
"Диаграммы развертывания", "Показывают, как контейнеры или компоненты размещаются на физических узлах: серверах, виртуальных машинах и т.д."
"Сценарии (Scenarios)", "Представляют собой диаграммы, показывающие, как пользователи взаимодействуют с системой в определённых сценариях."
```

### Context Diagram

Диаграмма контекста — это хороший стартовый пункт для диаграммирования и документирования программной системы, позволяющий отойти назад и увидеть общую картину. На диаграмме изображается ваша система как один блок в центре, окружённый её пользователями и другими системами, с которыми она взаимодействует.

Детализация здесь не важна, потому что это общий обзор, показывающий большую картину ландшафта системы. Следует сосредоточиться на **людях** (актёрах, ролях, персонах и т.д.) и **программных системах**, а не на технологиях, протоколах и других низкоуровневых деталях. Это как раз та диаграмма, которую можно показать нетехническим специалистам.

#### Пример

Пример диаграммы контекста:

(Система X в центре, пользователи и внешние системы вокруг)

#### Условные обозначения

(Пример легенды: люди, системы, соединения)

#### Область охвата

Одна программная система.

#### Основные элементы

Программная система, находящаяся в фокусе.

#### Вспомогательные элементы

Люди (например, пользователи, актёры, роли или персоны) и программные системы (внешние зависимости), которые напрямую связаны с системой в фокусе. Обычно эти системы находятся за пределами вашей собственной программной системы, и вы не несёте за них ответственности или владения.

#### Целевая аудитория

Все: как технические, так и нетехнические специалисты, как внутри, так и вне команды разработки.

#### Рекомендуется ли использовать?

Да, диаграмма контекста рекомендуется для всех команд разработки ПО.

### Container Diagram

После того как вы разобрались, как ваша система вписывается в общую ИТ-среду, полезным следующим шагом будет "приблизить" границу системы с помощью диаграммы контейнеров. В C4 **контейнер** — это **приложение или хранилище данных**, например, серверное веб-приложение, клиентское одностраничное приложение, десктопное приложение, мобильное приложение, схема базы данных, папка в файловой системе, бакет Amazon S3 и т.д.

Диаграмма контейнеров показывает **общую структуру архитектуры ПО** и как **распределены обязанности** между её частями. Также она отражает **основные технологические решения** и **способы взаимодействия контейнеров** друг с другом. Это простая, высокоуровневая **технологически ориентированная диаграмма**, полезная как для разработчиков, так и для персонала технической поддержки и эксплуатации.

#### Пример

Пример диаграммы контейнеров:

(Система X в центре, внутри неё контейнеры: веб-приложение, база данных, файловое хранилище и т.д.)

#### Условные обозначения

(Пример легенды: контейнеры, соединения, технологии)

#### Область охвата

Одна программная система.

#### Основные элементы

Контейнеры внутри программной системы, находящейся в фокусе.

#### Вспомогательные элементы

Люди и программные системы, напрямую связанные с контейнерами.

#### Целевая аудитория

Технические специалисты как внутри, так и вне команды разработки, включая архитекторов, разработчиков и сотрудников отделов эксплуатации/поддержки.

#### Рекомендуется ли использовать?

Да, диаграмма контейнеров рекомендуется для всех команд разработки ПО.

#### Примечания

Эта диаграмма **почти ничего не говорит** о **аспектах развертывания**, таких как кластеризация, балансировщики нагрузки, репликация, отказоустойчивость и т.д., поскольку они могут отличаться в разных средах (например, продакшн, стейджинг, разработка и т.д.). Информацию о развертывании лучше отражать с помощью одной или нескольких **диаграмм развертывания**, по одной на каждую среду.

### Component Diagram

Далее вы можете "приблизить" и разложить контейнер на **компоненты**, находящиеся внутри него, включая их **обязанности** и **технологические/реализационные детали**.

#### Пример

Пример диаграммы компонентов:

(Контейнер в центре, внутри него компоненты: контроллеры, сервисы, репозитории и т.д.)

#### Условные обозначения

(Пример легенды: компоненты, соединения, технологии)

#### Область охвата

Один контейнер.

#### Основные элементы

Компоненты внутри контейнера, находящегося в фокусе.

#### Вспомогательные элементы

Контейнеры (внутри программной системы, находящейся в фокусе), а также люди и программные системы, напрямую связанные с компонентами.

#### Целевая аудитория

Архитекторы и разработчики ПО.

#### Рекомендуется ли использовать?

**Нет**, создавайте диаграммы компонентов **только если считаете, что они приносят пользу**, и подумайте о **автоматизации их создания** для долгосрочной документации.

### Code Diagram

Наконец, вы можете "приблизить" компонент, чтобы показать, как он реализован в виде **кода**, используя UML-диаграммы классов, диаграммы взаимосвязей сущностей или аналогичные инструменты.

Это **весьма опциональный уровень детализации**, который часто доступен по требованию из таких инструментов, как IDE. В идеале такая диаграмма должна **автоматически генерироваться** с помощью инструментов (например, IDE или UML-редакторов), и вы должны **показывать только те атрибуты и методы**, которые помогают рассказать нужную историю. Такой уровень детализации **не рекомендуется** для всего, кроме **наиболее важных или сложных компонентов**.

#### Пример

Пример диаграммы кода:

(UML-диаграмма классов или ER-диаграмма для компонента)

#### Область охвата

Один компонент.

#### Основные элементы

Элементы кода (например, классы, интерфейсы, объекты, функции, таблицы базы данных и т.д.) внутри компонента, находящегося в фокусе.

#### Целевая аудитория

Архитекторы и разработчики ПО.

#### Рекомендуется ли использовать?

**Нет**, особенно для долгосрочной документации, потому что большинство IDE могут генерировать такой уровень детализации по требованию.

### Дополнительные диаграммы

#### Диаграмма ландшафта систем

Диаграммы контекста, контейнеров, компонентов и кода предназначены для предоставления **статического представления** одной программной системы, но в реальности программные системы **никогда не существуют изолированно**. По этой причине, особенно если вы отвечаете за **коллекцию/портфель программных систем**, часто бывает полезно понимать, как все эти системы **вписываются друг с другом** в заданном предприятии, организации, департаменте и т.д. По сути, это **карта программных систем** в выбранной области охвата, с набором диаграмм контекста, контейнеров, компонентов и кода для каждой интересующей системы.

С практической точки зрения, диаграмма ландшафта систем — это, по сути, **диаграмма контекста**, **не фокусирующаяся** на какой-то конкретной программной системе.

##### Пример

Пример диаграммы ландшафта систем:

(Карта всех систем в организации, пользователи, внешние системы)

##### Условные обозначения

(Пример легенды)

##### Область охвата

Предприятие/организация/департамент и т.д.

##### Основные элементы

Люди и программные системы, относящиеся к выбранной области охвата.

##### Целевая аудитория

Технические и нетехнические специалисты, как внутри, так и вне команды разработки ПО.

##### Рекомендуется ли использовать?

**Да**, особенно для крупных организаций — это мост в мир **архитектуры предприятия**.

---

#### Динамическая диаграмма

Динамическая диаграмма может быть полезна, когда вы хотите показать, **как элементы статической модели взаимодействуют во время выполнения**, чтобы реализовать пользовательскую историю, сценарий использования, функцию и т.д. Эта диаграмма основана на **UML-диаграмме взаимодействия** (ранее называвшейся "UML-диаграммой сотрудничества"). Она похожа на UML-диаграмму последовательности, но позволяет **свободное размещение элементов** с **пронумерованными взаимодействиями**, чтобы показать порядок.

##### Пример (стиль сотрудничества)

Пример динамической диаграммы:

(Элементы на диаграмме со стрелками, пронумерованными в порядке взаимодействия)

##### Условные обозначения

(Пример легенды)

##### Пример (стиль последовательности)

Динамическая диаграмма в стиле последовательности:

(Вертикальные линии жизни, горизонтальные стрелки взаимодействия)

##### Область охвата

Конкретная функция, история, сценарий использования и т.д.

##### Основные и вспомогательные элементы

На ваш выбор — вы можете показать взаимодействие программных систем, контейнеров или компонентов во время выполнения.

##### Целевая аудитория

Технические и нетехнические специалисты, как внутри, так и вне команды разработки ПО.

##### Рекомендуется ли использовать?

**Нет**, динамические диаграммы следует использовать **редко**, чтобы показать интересные/повторяющиеся паттерны или функции, требующие сложного набора взаимодействий.

##### Примечания

Стили "сотрудничество" и "последовательность" показывают **одну и ту же информацию по-разному**, поэтому вы можете использовать тот, который вам больше нравится.

---

#### Диаграмма развертывания

Диаграмма развертывания позволяет проиллюстрировать, **как экземпляры программных систем и/или контейнеров из статической модели развертываются на инфраструктуру** в заданной среде развертывания (например, продакшн, стейджинг, разработка и т.д.). Она основана на **UML-диаграмме развертывания**.

**Узел развертывания** — это место, где запускается экземпляр программной системы/контейнера; это может быть **физическая инфраструктура** (например, физический сервер или устройство), **виртуализированная инфраструктура** (например, IaaS, PaaS, виртуальная машина), **контейнеризованная инфраструктура** (например, Docker-контейнер), **среда выполнения** (например, сервер баз данных, Java EE веб/приложение-сервер, Microsoft IIS) и т.д. Узлы развертывания могут быть вложенными.

Вы также можете включить **инфраструктурные узлы**, такие как DNS-сервисы, балансировщики нагрузки, брандмауэры и т.д.

Не стесняйтесь использовать **иконки от Amazon Web Services, Azure и других**, чтобы дополнить диаграммы развертывания — просто убедитесь, что используемые иконки включены в **легенду диаграммы**.

##### Пример 1

Пример диаграммы развертывания:

(Серверы, виртуальные машины, контейнеры, соединения)

##### Условные обозначения

(Пример легенды)

##### Пример 2

Пример диаграммы развертывания:

(Развертывание в облаке: AWS, Azure и т.д.)

##### Условные обозначения

(Пример легенды)

##### Пример 3

Пример диаграммы развертывания:

(Сложная структура: кластеры, балансировщики, репликация и т.д.)

##### Условные обозначения

(Пример легенды)

##### Область охвата

Одна или несколько программных систем в одной среде развертывания (например, продакшн, стейджинг, разработка и т.д.).

##### Основные и вспомогательные элементы

Узлы развертывания, экземпляры программных систем и контейнеров.

##### Вспомогательные элементы

Инфраструктурные узлы, используемые при развертывании программной системы.

##### Целевая аудитория

Технические специалисты как внутри, так и вне команды разработки ПО, включая архитекторов, разработчиков, инфраструктурных архитекторов и сотрудников отделов эксплуатации/поддержки.

##### Рекомендуется ли использовать?

**Да**.