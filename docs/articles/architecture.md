# Архитектурные принципы

## Объяснение

Этот шаблон проекта следует современным принципам проектирования Python-приложений, стремясь к чистоте, тестируемости, расширяемости и отделению бизнес-логики от инфраструктурных деталей.

### 1. Слоистая архитектура (Layered Architecture)

Приложение разделено на логические слои, каждый из которых отвечает за определённый аспект функциональности:

*   **`src/main.py` (или API/Entrypoint):** Точка входа. Обрабатывает внешние запросы (если применимо) и делегирует работу слою сервисов.
*   **`src/utils/`:** Вспомогательные утилиты, общие для всего приложения (например, логирование). Не содержит бизнес-логики.
*   **`src/databases/`:** Слой доступа к данным.
    *   `models/`: ORM-модели (SQLAlchemy), отражающие структуру базы данных.
    *   `schemas/`: Pydantic-схемы для валидации данных (входящих, исходящих, внутренних). Используются для сериализации/десериализации.
    *   `dao/` (Data Access Object): Абстракции для взаимодействия с базой данных. Содержит методы для CRUD-операций и специфичных запросов. Изолирует остальные слои от деталей реализации базы данных.
*   **Слой бизнес-логики (если реализован):** Сервисы, содержащие основную логику приложения, координирующие работу DAO и других компонентов. (В текущем шаблоне может быть интегрирован в `main.py` или отсутствовать, если логика проста).

**Цель:** Разделение ответственностей. Каждый слой знает только о слоях *ниже* себя, что упрощает тестирование, изменение и понимание кода.

### 2. Использование Pydantic для валидации

Pydantic используется для определения схем данных (в `configs/schemas/` и `src/databases/schemas/`). Это обеспечивает:

*   **Строгую типизацию:** Явное определение структуры данных.
*   **Валидацию:** Автоматическая проверка входных данных на соответствие схеме.
*   **Сериализацию/Десериализацию:** Удобное преобразование между Python-объектами и JSON (или другими форматами).

### 3. Использование SQLAlchemy (ORM)

SQLAlchemy используется как Object-Relational Mapping (ORM) инструмент для взаимодействия с базой данных (в данном случае SQLite). Это позволяет:

*   Работать с базой данных через Python-объекты (модели).
*   Писать запросы на "питоновском" уровне, не прибегая к написанию чистого SQL (в большинстве случаев).
*   Использовать миграции (Alembic) для управления изменениями схемы БД.

### 4. Использование Alembic для миграций

Alembic интегрирован в проект для управления версиями схемы базы данных. Это позволяет:

*   Отслеживать изменения структуры БД как код.
*   Применять и откатывать изменения схемы в контролируемом порядке.
*   Обеспечивать согласованность структуры БД между различными средами (разработка, тестирование, продакшн).

### 5. Конфигурация через Pydantic Settings

Конфигурация приложения (`configs/settings.py`) использует `pydantic_settings.BaseSettings`. Это позволяет:

*   Централизованно управлять настройками.
*   Загружать настройки из переменных окружения.
*   Валидировать настройки при запуске приложения.

### 6. Принципы организации кода

*   **Конфигурация через файлы:** Использование `copier.yaml`, `pre-commit-config.yaml`, `docker-compose.yaml`, `requirements.txt` и т.д. позволяет декларативно описывать настройки проекта, окружения, зависимостей и процессов.
*   **Изолированные зависимости:** Использование виртуальных окружений (`venv`) и `requirements.txt` обеспечивает изоляцию зависимостей проекта.
*   **Автоматизация и CI/CD:** Использование `Makefile`, `pre-commit`, `docker-compose`, и GitHub Actions автоматизирует рутинные задачи и обеспечивает согласованность процессов разработки и деплоя.

### Почему выбрана такая архитектура?

*   **Простота:** Подходит для небольших и средних проектов, обеспечивая понятную структуру.
*   **Тестируемость:** Слоистая архитектура и использование Pydantic/SQLAlchemy облегчают написание модульных тестов.
*   **Согласованность:** Использование проверенных инструментов (SQLAlchemy, Pydantic) и практик (слои, валидация) делает код более предсказуемым и поддерживаемым.
*   **Современность:** Стек соответствует современным тенденциям разработки на Python.

### Альтернативные подходы

*   Для более сложных приложений может использоваться [Domain-Driven Design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design), [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html) или [Hexagonal Architecture](https://alistair.cockburn.us/hexagonal-architecture/), вводя более строгие границы и абстракции.
*   Вместо SQLAlchemy ORM можно использовать "сырой" SQL или другие библиотеки, такие как [SQLModel](https://sqlmodel.tiangolo.com/), который сочетает в себе возможности SQLAlchemy и Pydantic.
*   Вместо слоя DAO можно использовать паттерн [Repository](https://medium.com/@sanketdashore/understanding-the-repository-pattern-in-python-django-9d278c3b0a9a) или интегрировать логику доступа к данным непосредственно в сервисы.