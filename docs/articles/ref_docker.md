# Docker

Docker — это популярная платформа, которая позволяет разработчикам упаковывать приложения и все их зависимости (библиотеки, системные настройки, код) в **контейнеры**.

```{question} Зачем вообще нужен Docker
Представьте, что ваша программа работает на вашем компьютере, но не запускается на компьютере коллеги или на сервере, потому что у них другая операционная система или отсутствуют нужные библиотеки. Docker решает эту проблему. Контейнер — это как мини-компьютер, в котором есть всё необходимое для запуска вашего приложения. Вы можете передать этот контейнер по сети кому угодно, и он будет работать *одинаково* на любом компьютере, где установлен Docker.
```

## Основные понятия Docker

### Образ (Image)

Образ Docker — это **шаблон** или **файл конфигурации**, описывающий, как должен выглядеть контейнер. Это неизменяемый файл, содержащий:
*   Базовую операционную систему (например, Ubuntu, Alpine Linux).
*   Код вашего приложения.
*   Все зависимости и библиотеки, необходимые для его работы.
*   Инструкции по запуску приложения.

Образы можно представлять как "рецепт" для создания контейнера. Образы хранятся в специальных репозиториях, таких как Docker Hub. Вы можете использовать готовые образы (например, образ Python) или создавать свои собственные.

### Контейнер (Container)

Контейнер — это **запущенная копия образа**. Это изолированная среда выполнения, в которой работает ваше приложение. Контейнеры:
*   **Изолированы** от остальной системы.
*   **Легковесны**, так как не требуют запуска полноценной виртуальной машины.
*   **Портативны**,  т.е могут быть запущены на любом компьютере с Docker.

## Dockerfile

Файл `Dockerfile` содержит пошаговые инструкции для создания Docker-образа вашего приложения. Он определяет, на каком базовом образе строится приложение, какие зависимости устанавливаются, какие файлы копируются и как запускается само приложение.

```{eval-rst}
.. toggle:: Показать

   .. literalinclude:: ../../Dockerfile
      :language: docker
      :caption: Dockerfile
```

**Описание инструкций:**

1.  `FROM python:3.12-slim`: Начинает сборку с официального образа Python 3.12, версии `slim`, которая меньше по размеру.
2.  `ARG ...`: Определяет переменные, значения которых можно передать во время сборки образа (например, из `docker-compose.yaml`).
3.  `RUN apt-get ...`: Обновляет пакеты, устанавливает и настраивает локали (включая русские), затем очищает кэш для уменьшения размера образа.
4.  `ENV LANG ...`: Устанавливает переменные окружения для локали и кодировки Python.
5.  `WORKDIR /${APP_NAME}`: Устанавливает рабочую директорию внутри контейнера.
6.  `RUN groupadd ... useradd ...`: Создаёт нового пользователя и группу внутри контейнера для повышения безопасности (запуск приложения не от root).
7.  `COPY requirements.txt .`: Копирует файл зависимостей в образ.
8.  `RUN pip install ...`: Устанавливает Python-зависимости.
9.  `COPY --chown=${DEPLOY_USER_NAME}:${DEPLOY_USER_NAME} . .`: Копирует исходный код проекта в контейнер и устанавливает владельца файлов на созданного пользователя.
10. `USER ${DEPLOY_USER_NAME}`: Переключается на созданного пользователя для запуска приложения.
11. `CMD ["python", "-m", "src.main"]`: Команда, которая выполняется при запуске контейнера. В данном случае запускает основной файл приложения `src/main.py`.

## docker-compose.yaml

Файл `docker-compose.yaml` позволяет определить и управлять многоконтейнерным приложением. Он описывает, какие сервисы (например, само приложение, база данных) должны быть запущены, как они связаны между собой, и какие у них настройки (порт, переменные окружения, volumes).

```{eval-rst}
.. toggle:: Показать

   .. literalinclude:: ../../docker-compose.yaml
      :language: yaml
      :caption: docker-compose.yaml
```

**Описание:**

*   `container_name: ${DOCKER_CONTAINER_NAME}`: Устанавливает имя контейнера, используя значение из `.env`.
*   `build: ...`: Указывает, что образ для контейнера нужно собрать из текущей директории, используя `Dockerfile`. Передаёт переменные (`UID`, `GID`, `DEPLOY_USER_NAME`, `APP_NAME`, `APP_PORT`) в процесс сборки.
*   `command: python src/main.py`: Переопределяет команду `CMD` из `Dockerfile`, указывая, как именно запустить приложение.
*   `volumes: - .:/${APP_NAME}`: Монтирует текущую директорию проекта на хост-машине в директорию `/${APP_NAME}` внутри контейнера. Это позволяет видеть изменения в коде в реальном времени (полезно при разработке).
*   `env_file: - .env`: Загружает переменные окружения из файла `.env`.
*   `ports: - "${DOCKER_PORT}:${APP_PORT}"`: Пробрасывает порт с хост-машины (`DOCKER_PORT` из `.env`) на порт внутри контейнера (`APP_PORT` из `.env`), позволяя получить доступ к приложению извне.
*   `restart: unless-stopped`: Настройка перезапуска контейнера. Он будет автоматически перезапущен, если остановится, за исключением случаев, когда его остановили вручную.
*   `tty: true` и `stdin_open: true`: Позволяют подключаться к контейнеру и использовать интерактивные команды.
*   `environment: - PYTHONIOENCODING=utf-8`: Устанавливает переменную окружения внутри контейнера.

## .dockerignore

Файл `.dockerignore` аналогичен `.gitignore`, но используется Docker'ом при *сборке образа*. Он указывает, какие файлы и директории *не нужно* включать в *контекст сборки* — папку, которая передаётся Docker-демону для создания образа.

```{question} Зачем это нужно?
*   **Уменьшение размера контекста:** Исключение ненужных файлов (например, `.git`, логов, кэша IDE) уменьшает объём данных, передаваемых при сборке, что ускоряет процесс.
*   **Ускорение сборки:** Меньше файлов — быстрее анализ и копирование.
*   **Безопасность:** Предотвращает случайное включение конфиденциальных файлов (например, `.env` с токенами) в образ.
```
```{eval-rst}
.. toggle:: Показать

   .. literalinclude:: ../../.dockerignore
      :language: text
      :caption: .dockerignore
```

**Описание исключений:**
*   **`.git`**: Репозиторий Git не нужен внутри контейнера.
*   **`.env`, `*.log`, `*.pyc`, `__pycache__`**: Конфиденциальные данные, логи и временные файлы Python.
*   **`venv/`, `.pytest_cache/`**: Локальные виртуальные окружения и кэши тестов.
*   **`.vscode/`, `.idea/`**: Файлы настроек IDE.
*   **`node_modules/`, `dist/`, `build/`**: Артефакты сборки и зависимости, не относящиеся к Python-приложению или не нужные в финальном образе.
*   **`docs/`, `README.md`**: Документация, возможно, не нужна в контейнере приложения.

## 🧰 Makefile

Файл `Makefile` — это файл с набором команд (так называемых "задач" или "правил"), который позволяет автоматизировать часто используемые операции в проекте. Вместо того чтобы каждый раз вводить длинные команды Docker Compose, вы можете использовать короткие команды `make`, определённые в `Makefile`.

```{eval-rst}
.. toggle:: Показать

   .. literalinclude:: ../../Makefile
      :language: make
      :caption: Makefile
```

**Описание:**

*   `include .env`: Загружает переменные из файла `.env`, чтобы они были доступны в `Makefile`.
*   `up`: Запускает все сервисы, описанные в `docker-compose.yaml`, в фоновом режиме (`-d`).
*   `down`: Останавливает и удаляет контейнеры, созданные `docker-compose up`, но *не удаляет* образы.
*   `restart`: Комбинация `down` и `up`, быстро перезапускает контейнеры без пересборки образа. Полезно, если вы изменили код приложения.
*   `build`: Пересобирает образы, используя `docker-compose build`, с флагом `--no-cache`, игнорируя кэш. Используется, если изменились `Dockerfile` или `requirements.txt`.
*   `rebuild`: Полный цикл пересоздания: `prune` (очистка), `build` (пересборка), `up` (запуск).
*   `logs`: Показывает логи контейнера с именем, указанным в переменной `DOCKER_CONTAINER_NAME`, в реальном времени (`-f`).
*   `bash`: Открывает интерактивную сессию bash (или sh) внутри указанного сервиса (по умолчанию `app`). Это позволяет "войти" в работающий контейнер и выполнить команды вручную.
*   `prune`: Удаляет остановленные контейнеры, *локальные* (построенные локально) образы, неиспользуемые сети и тома, связанные с проектом.
*   `docs-clean`: Выполняет команду `make clean` в директории `docs`, очищая предыдущие сборки документации Sphinx.
*   `docs-html`: Выполняет команду `make html` в директории `docs`, генерируя HTML-версию документации.
*   `help`: Выводит список доступных команд и краткое описание для каждой.

## 🔗 Полезные ссылки

*   [Официальная документация Docker](https://docs.docker.com/)
*   [Docker Compose documentation](https://docs.docker.com/compose/)
*   [Примеры и туториалы на Habr](https://habr.com/ru/companies/ruvds/articles/438796/)